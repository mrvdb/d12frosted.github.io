<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>d12frosted - Cabal and executables</title>
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
    <link rel="stylesheet" type="text/css" href="../css/font-awesome.css" />
  </head>
  <header>
    <ul class="nav-list">
      <li class="nav-elem nav-left nav-head">
        <a href="../"><i class="fa fa-home"></i> d12frosted</a>
      </li>
      <li class="nav-elem nav-left nav-head">
        <a href="../archive.html"><i class="fa fa-archive"></i> Archive</a>
      </li>
      <li class="nav-elem nav-right">
        <a href="http://stackoverflow.com/users/3086454/d12frosted"><i class="fa fa-stack-overflow"></i> StackOverflow</a>
      </li>
      <li class="nav-elem nav-right">
        <a href="https://github.com/d12frosted"><i class="fa fa-github"></i> GitHub</a>
      </li>
    </ul>
  </header>

  <body>
    <div id="content">
      <h1>Cabal and executables</h1>

      <p>I am the person that runs into <strong>Cabal Hell</strong> very frequently. And most often it happens when I need to install specific package very urgently.</p>
<p><strong>Update on 2016-03-15 Tue</strong></p>
<p>Since <code>stack</code> is out - forget about my solution. Long live great solutions!</p>
<blockquote>
<p><strong>Cabal Hell</strong></p>
<p>The feeling of powerlessness one has when Cabal does not do what one wanted and one does not know how to fix it.</p>
<p><a href="http://www.well-typed.com/blog/2014/09/how-we-might-abolish-cabal-hell-part-1/">Well Typed</a></p>
</blockquote>
<blockquote>
<p><strong>What is the difficulty caused by Cabal-install?</strong></p>
<p>The main difficulty with Cabal is otherwise known as ‘dependency hell’, in which the cabal-install does not manage to install a desired package for a reason or another, leading to large amount of manual work. As an example of this difficulty, consider a case where the user wishes to install packages A and B. Both of these work with package C, but not with the same version of C.</p>
<p><a href="https://wiki.haskell.org/Cabal/Survival">Haskell Wiki</a></p>
</blockquote>
<div class="figure">
<img src="../images/1428233775.png" alt>
<p class="caption"></p>
</div>
<p>I need to confess. Sometimes I solve <strong>*Cabal Hell*</strong> by using this method with <code>rm -rf</code>. <strong>*Cabal Hell*</strong> is like a cancer - it’s very hard to cure this disease without ruining your environment (in our case - packages database). But with <strong>Cabal Hell</strong> comes one good thing - you can use some tools in order to prevent this bizarre to happen with you. For such purposes you can use cabal sandboxes, <a href="http://www.stackage.org">Stackage</a> or <a href="http://hydra.nixos.org">nixos</a>. Probably there are some other handy solutions or tools, but this is all I know.</p>
<p><code>Stackage</code> is great, but it doesn’t work for me very well, because sometimes I need to install ‘heavy’ packages that are not on <code>Stackage</code>. Also I work on reliably fast computer, so I don’t mind to waste thirty seconds more on compilation. Safety is more preferable. As for <code>nixos</code> – I haven’t tried it yet. But I know that it helps to find compilation problems very good. So actually, many thanks for the people that made <code>Stackage</code> and <code>nixos</code>.</p>
<h1 id="sec-1">Sandboxes</h1>
<p>I think that sandboxes are really great. Usually I install globally only commonly used packages. Everything else comes via sandboxes. Sometimes the project I am working on has dependencies that can’t be installed from hackage. In such cases I use</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> sandbox add-source path/to/non-hackage/dependency</code></pre></div>
<p>So I don’t need to install such dependencies globally. And if this dependency is very heavy and problem-bringing, then it can save my global packages database.</p>
<p>But you use haskell not only for writing libraries (funny, isn’t it?). Sometimes you need to install some executables. So here comes the ‘executables’ part.</p>
<p>Usually I install executables by using following sequence of commands:</p>
<pre class="fish"><code>$ cd path/to/cabal/project
$ cabal sandbox init
$ cabal install --only-dependencies
$ cabal install
$ cp .cabal-sandbox/bin/executable ~/.bin/executable
</code></pre>
<p>This works because, executables are usually completely stand-alone, so you can build them in a sandbox and then move them to any location of your choice. This approach helps to keep system (or user) wide packages database clean and free from conflicts. I move executable into <code>~/.bin</code> (but make sure that <code>~/.bin</code> is in <code>$PATH</code>), because when something breaks in my packages database I want to keep this executables (they made nothing bad!).</p>
<p>But it’s very boring to call this commands every time I want to install any executables, so I wrote a simple <code>fish</code> function that installs executable from <code>.cabal</code> file in current directory for you.</p>
<pre class="fish"><code>function cabal-install-bin -d &quot;Install executables from .cabal file in current directory&quot;
  # set some color settings
  set -l error_color red
  set -l msg_color blue

  # get cabal file in current directory
  set -l cb *.cabal

  set -l c (count *.cabal)
  # we expect only 1 cabal file to be existing
  if test c -ne 1
    set_color $error_color
    if test c -eq 0
      echo &quot;Couldn' find cabal file in (pwd)&quot;
    else
      echo &quot;Found $c cabal files. Think about it!&quot;
    end
    set_color normal
    return 1
  end

  set_color $msg_color
  echo &quot;Using $cb&quot;

  # check if sandbox is not created yet
  if test ! \( -e .cabal-sandbox \) -o ! \( -e cabal.sandbox.config \)
    echo &quot;It looks like there is no sandbox, so creating one&quot;
    set_color normal
    # create sandbox
    cabal sandbox init
  end

  # todo add support of multiple executables
  set -l name (cabal info *.cabal | sed -ne &quot;s/ *Executables: *\(.*\)/\1/p&quot;)

  # check that the name is not empty
  if test ! \( -n $name \)
    set_color $error_color
    echo &quot;Couldn't find any executable in cabal file&quot;
    set_color normal
    return 1
  end

  set_color $msg_color
  echo &quot;Found executables: $name&quot;
  echo &quot;Installing dependencies&quot;
  set_color normal

  # first we want to install dependencies
  # we could just ~cabal install~
  # but I find separate installation
  # more satisfying
  cabal install --only-dependencies

  if test $status -ne 0
    return 1
  end

  set_color $msg_color
  echo &quot;Building application&quot;
  set_color normal

  # install package
  cabal install

  if test $status -ne 0
    return 1
  end

  set_color $msg_color
  echo &quot;Copying $name to ~/.bin&quot;
  set_color normal
  # now copy executable to ~/.bing
  cp &quot;.cabal-sandbox/bin/$name&quot; &quot;$HOME/.bin/$name&quot;
end
</code></pre>
<p>But for situations when I don’t care about package sources and it’s available on hackage, I wrote another function (that reuses <code>cabal-install-bin</code>).</p>
<pre class="fish"><code>function cabal-unpack-and-install-bin -a package -d &quot;Unpack and install specified executable package from cabal.&quot;
  set -l current_dir (pwd)
  cd $TMPDIR
  set -l dir $package*

  if test (count $dir) -ne 0
    echo &quot;Found $TMPDIR$dir&quot;
    echo &quot;Looks like the package already unpacked in \$TMPDIR&quot;
    cd $current_dir
    return 1
  end

  cabal unpack $package

  if test $status -ne 0
    cd $current_dir
    return 1
  end

  set -l dir $package*

  cd $TMPDIR/$dir

  cabal-install-bin

  cd $TMPDIR
  rm -rf $dir

  cd $current_dir
end
</code></pre>
<p>It just downloads sources of single package to the <code>$TMPDIR</code> (you might want to change this to something different, depending on your system), then installs executable (using <code>cabal-install-bin</code> function) and removes sources dir. Useful, isn’t it?</p>
<p>You can grab the latest version of these function on <a href="https://github.com/d12frosted/environment/tree/master/fish/functions">github</a>.</p>
<p><strong>Happy Haskell coding!</strong></p>

<div id="info">
  <p>
    Posted on April  5, 2015
    
      by Boris Buliga
    
  </p>
  <p>
    Source: <a href="https://github.com/d12frosted/d12frosted.github.io/blob/source/posts/Cabal-and-executables.org">Cabal and executables</a>
  </p>
</div>

    </div>
  </body>
</html>
