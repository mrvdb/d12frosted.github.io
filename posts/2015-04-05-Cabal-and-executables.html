<!DOCTYPE html>
<html>
<head>
  <title>d12frosted - Cabal and executables</title>
  <meta charset="UTF-8">
  <link href="http://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
  <link href="http://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet" type="text/css">
  <link href="../css/all.css" rel="stylesheet" type="text/css">
</head>

<body>
  <header>
    <ul class="nav-list">
      <li class="nav-elem nav-left nav-head">
        <a href="../">d12frosted</a>
      </li>
      <li class="nav-elem nav-left ">
        <a href="../archive.html">Archive</a>
      </li>
      <li class="nav-elem nav-right">
        <a href="https://github.com/d12frosted">
          <img src="../images/github-icon.png">
          GitHub
        </a>
      </li>
    </ul>
  </header>

  <main>
    <h1>Cabal and executables</h1>

<p>I am the person that runs into <strong>Cabal Hell</strong> very frequently. And most often it happens when I need to install specific package very urgently.</p>
<div class="figure">
<img src="../images/1428233775.png" />
</div>
<p>I need to confess. Sometimes I solve <strong><strong>Cabal Hell</strong></strong> by using this method with <code>rm -rf</code>. <strong><strong>Cabal Hell</strong></strong> is like a cancer - it’s very hard to cure this disease without ruining your environment (in our case - packages database). But with <strong>Cabal Hell</strong> comes one good thing - you can use some tools in order to prevent this bizarre to happen with you. For such purposes you can use cabal sandboxes, <a href="http://www.stackage.org">Stackage</a> or <a href="http://hydra.nixos.org">nixos</a>. Probably there are some other handy solutions or tools, but this is all I know.</p>
<p><code>Stackage</code> is great, but it doesn’t work for me very well, because sometimes I need to install ‘heavy’ packages that are not on <code>Stackage</code>. Also I work on reliably fast computer, so I don’t mind to waste thirty seconds more on compilation. Safety is more preferable. As for <code>nixos</code> – I haven’t tried it yet. But I know that it helps to find compilation problems very good. So actually, many thanks for the people that made <code>Stackage</code> and <code>nixos</code>.</p>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Sandboxes</h2>
<div id="text-1" class="outline-text-2">
<p>I think that sandboxes are really great. Usually I install globally only commonly used packages. Everything else comes via sandboxes. Sometimes the project I am working on has dependencies that can’t be installed from hackage. In such cases I use</p>
<div class="org-src-container">
<pre class="sourceCode src src-bash bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> sandbox add-source path/to/non-hackage/dependency</code></pre>
</div>
<p>So I don’t need to install such dependencies globally. And if this dependency is very heavy and problem-bringing, then it can save my global packages database.</p>
<p>But you use haskell not only for writing libraries (funny, isn’t it?). Sometimes you need to install some executables. So here comes the ‘executables’ part.</p>
<p>Usually I install executables by using following sequence of commands:</p>
<div class="org-src-container">
<pre class="sourceCode src src-fish bash"><code class="sourceCode bash">$ <span class="kw">cd</span> path/to/cabal/project
$ <span class="kw">cabal</span> sandbox init
$ <span class="kw">cabal</span> install --only-dependencies
$ <span class="kw">cabal</span> install
$ <span class="kw">cp</span> .cabal-sandbox/bin/executable ~/.bin/executable</code></pre>
</div>
<p>This works because, executables are usually completely stand-alone, so you can build them in a sandbox and then move them to any location of your choice. This approach helps to keep system (or user) wide packages database clean and free from conflicts. I move executable into <code>~/.bin</code> (but make sure that <code>~/.bin</code> is in <code>$PATH</code>), because when something breaks in my packages database I want to keep this executables (they made nothing bad!).</p>
<p>But it’s very boring to call this commands every time I want to install any executables, so I wrote a simple <code>fish</code> function that installs executable from <code>.cabal</code> file in current directory for you.</p>
<div class="org-src-container">
<pre class="sourceCode src src-fish bash"><code class="sourceCode bash"><span class="kw">function</span><span class="fu"> cabal-install-bin</span> <span class="kw">-d</span> <span class="st">&quot;Install executables from .cabal file in current directory&quot;</span>
  <span class="co"># set some color settings</span>
  <span class="kw">set</span> <span class="kw">-l</span> error_color red
  <span class="kw">set</span> <span class="kw">-l</span> msg_color blue

  <span class="co"># get cabal file in current directory</span>
  <span class="kw">set</span> <span class="kw">-l</span> cb *.cabal

  <span class="kw">set</span> <span class="kw">-l</span> c (count *.cabal)
  <span class="co"># we expect only 1 cabal file to be existing</span>
  <span class="kw">if</span> <span class="kw">test</span> c -ne 1
    <span class="kw">set_color</span> <span class="ot">$error_color</span>
    <span class="kw">if</span> <span class="kw">test</span> c -eq 0
      <span class="kw">echo</span> <span class="st">&quot;Couldn' find cabal file in (pwd)&quot;</span>
    <span class="kw">else</span>
      <span class="kw">echo</span> <span class="st">&quot;Found </span><span class="ot">$c</span><span class="st"> cabal files. Think about it!&quot;</span>
    <span class="kw">end</span>
    <span class="kw">set_color</span> normal
    <span class="kw">return</span> 1
  <span class="kw">end</span>

  <span class="kw">set_color</span> <span class="ot">$msg_color</span>
  <span class="kw">echo</span> <span class="st">&quot;Using </span><span class="ot">$cb</span><span class="st">&quot;</span>

  <span class="co"># check if sandbox is not created yet</span>
  <span class="kw">if</span> <span class="kw">test</span> ! <span class="dt">\(</span> -e .cabal-sandbox <span class="dt">\)</span> -o ! <span class="dt">\(</span> -e cabal.sandbox.config <span class="dt">\)</span>
    <span class="kw">echo</span> <span class="st">&quot;It looks like there is no sandbox, so creating one&quot;</span>
    <span class="kw">set_color</span> normal
    <span class="co"># create sandbox</span>
    <span class="kw">cabal</span> sandbox init
  <span class="kw">end</span>

  <span class="co"># todo add support of multiple executables</span>
  <span class="kw">set</span> <span class="kw">-l</span> name (cabal info *.cabal <span class="kw">|</span> <span class="kw">sed</span> -ne <span class="st">&quot;s/ *Executables: *\(.*\)/\1/p&quot;</span>)

  <span class="co"># check that the name is not empty</span>
  <span class="kw">if</span> <span class="kw">test</span> ! <span class="dt">\(</span> -n <span class="ot">$name</span> <span class="dt">\)</span>
    <span class="kw">set_color</span> <span class="ot">$error_color</span>
    <span class="kw">echo</span> <span class="st">&quot;Couldn't find any executable in cabal file&quot;</span>
    <span class="kw">set_color</span> normal
    <span class="kw">return</span> 1
  <span class="kw">end</span>

  <span class="kw">set_color</span> <span class="ot">$msg_color</span>
  <span class="kw">echo</span> <span class="st">&quot;Found executables: </span><span class="ot">$name</span><span class="st">&quot;</span>
  <span class="kw">echo</span> <span class="st">&quot;Installing dependencies&quot;</span>
  <span class="kw">set_color</span> normal

  <span class="co"># first we want to install dependencies</span>
  <span class="co"># we could just ~cabal install~</span>
  <span class="co"># but I find separate installation</span>
  <span class="co"># more satisfying</span>
  <span class="kw">cabal</span> install --only-dependencies

  <span class="kw">if</span> <span class="kw">test</span> <span class="ot">$status</span> -ne 0
    <span class="kw">return</span> 1
  <span class="kw">end</span>

  <span class="kw">set_color</span> <span class="ot">$msg_color</span>
  <span class="kw">echo</span> <span class="st">&quot;Building application&quot;</span>
  <span class="kw">set_color</span> normal

  <span class="co"># install package</span>
  <span class="kw">cabal</span> install

  <span class="kw">if</span> <span class="kw">test</span> <span class="ot">$status</span> -ne 0
    <span class="kw">return</span> 1
  <span class="kw">end</span>

  <span class="kw">set_color</span> <span class="ot">$msg_color</span>
  <span class="kw">echo</span> <span class="st">&quot;Copying </span><span class="ot">$name</span><span class="st"> to ~/.bin&quot;</span>
  <span class="kw">set_color</span> normal
  <span class="co"># now copy executable to ~/.bing</span>
  <span class="kw">cp</span> <span class="st">&quot;.cabal-sandbox/bin/</span><span class="ot">$name</span><span class="st">&quot;</span> <span class="st">&quot;</span><span class="ot">$HOME</span><span class="st">/.bin/</span><span class="ot">$name</span><span class="st">&quot;</span>
<span class="kw">end</span></code></pre>
</div>
<p>But for situations when I don’t care about package sources and it’s available on hackage, I wrote another function (that reuses <code>cabal-install-bin</code>).</p>
<div class="org-src-container">
<pre class="sourceCode src src-fish bash"><code class="sourceCode bash"><span class="kw">function</span><span class="fu"> cabal-unpack-and-install-bin</span> <span class="kw">-a</span> package -d <span class="st">&quot;Unpack and install specified executable package from cabal.&quot;</span>
  <span class="kw">set</span> <span class="kw">-l</span> current_dir (pwd)
  <span class="kw">cd</span> <span class="ot">$TMPDIR</span>
  <span class="kw">set</span> <span class="kw">-l</span> dir <span class="ot">$package</span>*

  <span class="kw">if</span> <span class="kw">test</span> (count <span class="ot">$dir</span>) <span class="kw">-ne</span> 0
    <span class="kw">echo</span> <span class="st">&quot;Found </span><span class="ot">$TMPDIR$dir</span><span class="st">&quot;</span>
    <span class="kw">echo</span> <span class="st">&quot;Looks like the package already unpacked in </span><span class="dt">\$</span><span class="st">TMPDIR&quot;</span>
    <span class="kw">cd</span> <span class="ot">$current_dir</span>
    <span class="kw">return</span> 1
  <span class="kw">end</span>

  <span class="kw">cabal</span> unpack <span class="ot">$package</span>

  <span class="kw">if</span> <span class="kw">test</span> <span class="ot">$status</span> -ne 0
    <span class="kw">cd</span> <span class="ot">$current_dir</span>
    <span class="kw">return</span> 1
  <span class="kw">end</span>

  <span class="kw">set</span> <span class="kw">-l</span> dir <span class="ot">$package</span>*

  <span class="kw">cd</span> <span class="ot">$TMPDIR</span>/<span class="ot">$dir</span>

  <span class="kw">cabal-install-bin</span>

  <span class="kw">cd</span> <span class="ot">$TMPDIR</span>
  <span class="kw">rm</span> -rf <span class="ot">$dir</span>

  <span class="kw">cd</span> <span class="ot">$current_dir</span>
<span class="kw">end</span></code></pre>
</div>
<p>It just downloads sources of single package to the <code>$TMPDIR</code> (you might want to change this to something different, depending on your system), then installs executable (using <code>cabal-install-bin</code> function) and removes sources dir. Useful, isn’t it?</p>
<p>You can grab the latest version of these function on <a href="https://github.com/d12frosted/environment/tree/master/fish/functions">github</a>.</p>
<p><strong>Happy Haskell coding!</strong></p>
</div>
</div>

<div class="info">
    Posted on April  5, 2015
    
</div>

  </main>

  <footer>
  </footer>
</body>
</html>
