<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>d12frosted - Fish mode for emacs (v2)</title>
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
    <link rel="stylesheet" type="text/css" href="../css/font-awesome.css" />
  </head>
  <header>
    <ul class="nav-list">
      <li class="nav-elem nav-left nav-head">
        <a href="../"><i class="fa fa-home"></i> d12frosted</a>
      </li>
      <li class="nav-elem nav-left nav-head">
        <a href="../archive.html"><i class="fa fa-archive"></i> Archive</a>
      </li>
      <li class="nav-elem nav-right">
        <a href="http://stackoverflow.com/users/3086454/d12frosted"><i class="fa fa-stack-overflow"></i> StackOverflow</a>
      </li>
      <li class="nav-elem nav-right">
        <a href="https://github.com/d12frosted"><i class="fa fa-github"></i> GitHub</a>
      </li>
    </ul>
  </header>

  <body>
    <div id="content">
      <h1>Fish mode for emacs (v2)</h1>

      <p>In educational purposes I implemented <code>fish-mode</code> for emacs. It is very simple and still has some problems with indenting complex stuff. But it works in most cases very well. You can grab it <a href="https://github.com/d12frosted/fish-mode">here</a>.</p>
<p>In case you have nothing else to do, read further for some details.</p>
<h2 id="sec-1-0">Update on 20 May 2015, Wednesday</h2>
<p>Good news everyone, we merged my changes to main package, so go and install latest version from <a href="http://melpa.org/#/fish-mode">MELPA</a>.</p>
<h2 id="sec-2-0">Update on 01 May 2015, Friday</h2>
<p>Indentation rules were improved. So now it works even in most esoteric cases. Also I have stolen syntax highlighting rules from the package that is available on MELPA. Currently working om merging my changes with the default package.</p>
<h1 id="sec-1">Long story</h1>
<p>While I was playing with <code>fish</code>, I felt acute shortage of <code>fish-mode</code> for emacs. My needs are modest - syntax highlighting and indentation. So I searched for existing modes and found one that is also available on MELPA. As usual I installed it from <a href="https://github.com/wwwjfy/emacs-fish">git</a> and found that it works not as I expected. Syntax highlighting worked not as I wanted and most importantly - indentation was buggy. Especially for <code>end</code> term. So I checked the code to fix it. But you know, my emacs lisp fu is pretty weak, so I couldn’t understand where lies the problem (well, definitely the problem is with <code>fish-indent-line</code> function). So I thought that I could implement my own major mode in educational purposes(yay!).</p>
<div class="figure">
<img src="../images/1423468417-fish-mode.png" alt>
<p class="caption"></p>
</div>
<p>My starting point was tutorial on <a href="http://ergoemacs.org/emacs/elisp_syntax_coloring.html">ergoemacs</a> that was describing how to implement major-mode for syntax highlighting. So pretty quickly I conquered this topic and implemented some very simple highlighting rules. And then started working on indentation functions. Fish language is really easy. In this language only blocks change indentation. Block begins with one of block-opening terms (<code>if</code>, <code>function</code>, <code>while</code>, <code>for</code>, <code>begin</code> and <code>switch</code>). Every block is closed by <code>end</code>. There is only one construction that makes indentation implementation a bit harder - <code>switch-case</code>, because <code>case</code> opens block and closes previous <code>case</code> block if previous one exists. And there is also another special term <code>else</code> that closes <code>if</code> block, but begins new one. So I started pretty straightforward.</p>
<div class="sourceCode"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(<span class="kw">defun</span><span class="fu"> fish-indent-line </span>()
  <span class="st">&quot;Indent current line&quot;</span>
  (interactive)

  (<span class="kw">if</span> (bobp)
      (indent-line-to <span class="dv">0</span>)
    (<span class="kw">let</span> (cur-indent)
      (save-excursion
        (beginning-of-line)
        (<span class="kw">cond</span>
         <span class="co">;; already on line 1, so leave it alone</span>
         ((<span class="kw">eq</span> (what-line-number) <span class="dv">1</span>)
          (<span class="kw">setq</span> cur-indent (current-indentation)))

         <span class="co">;; found 'end' - need to move back based on level of matching pair</span>
         ((looking-at <span class="st">&quot;[ </span>\t<span class="st">]*</span>\\<span class="st">(end</span>\\<span class="st">)&quot;</span>)
          (<span class="kw">setq</span> cur-indent (fish-get-end-indent)))

         <span class="co">;; found 'case' - need to move forth based on matching switch</span>
         ((looking-at <span class="st">&quot;[ </span>\t<span class="st">]*</span>\\<span class="st">(case</span>\\<span class="st">)&quot;</span>)
          (<span class="kw">setq</span> cur-indent (fish-get-case-indent)))

         <span class="co">;; found 'else' - like default condition, but also move left</span>
         ((looking-at <span class="st">&quot;[ </span>\t<span class="st">]*</span>\\<span class="st">(else</span>\\<span class="st">)&quot;</span>)
          (<span class="kw">setq</span> cur-indent (<span class="kw">-</span> (fish-get-normal-indent) tab-width)))

         <span class="co">;; default case - indent based on previous non-empty line</span>
         (<span class="kw">t</span>
          (<span class="kw">setq</span> cur-indent (fish-get-normal-indent)))))
      (<span class="kw">if</span> (<span class="kw">&lt;</span> cur-indent <span class="dv">0</span>) (<span class="kw">setq</span> cur-indent <span class="dv">0</span>))
      (indent-line-to cur-indent))))</code></pre></div>
<p>So as you can see, indentation function makes just what I described previously. But it also has some performance improvements. For example, <code>else</code> indentation. Ideally, it should search for matching <code>if</code> term and set indentation level of <code>else</code> to the same level as matching <code>if</code>. But <code>else</code> does make sense only if it is inside of matching <code>if</code> block, so we can use current block indentation level and subtract from it <code>tab-width</code>.</p>
<pre class="fish"><code>if test $VAR # opens 'if' block
  begin # opens 'begin' block
    do_something
  else # doesn't belong to if, because it's inside of 'begin' block
  end # closes 'begin' block - read more to find out why it closes 'begin' and not 'else'
end # closes 'if' block
</code></pre>
<p>I hope that previous example makes it clear, why we don’t need to search for matching <code>if</code>. First helper function we should read - <code>fish-get-normal-indent</code>.</p>
<div class="sourceCode"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(<span class="kw">defun</span><span class="fu"> fish-get-normal-indent </span>()
  (interactive)
  (<span class="kw">let</span> ((not-indented <span class="kw">t</span>) cur-indent)
    (while not-indented
      <span class="co">;; move up</span>
      (forward-line -<span class="dv">1</span>)
      (<span class="kw">cond</span>
       <span class="co">;; found block-opening term, so increase indentation level by tab-width</span>
       ((looking-at <span class="st">&quot;[ </span>\t<span class="st">]*</span>\\<span class="st">(if</span>\\<span class="st">|else</span>\\<span class="st">|function</span>\\<span class="st">|while</span>\\<span class="st">|for</span>\\<span class="st">|begin</span>\\<span class="st">|switch</span>\\<span class="st">|case</span>\\<span class="st">)&quot;</span>)
        (<span class="kw">setq</span> cur-indent (<span class="kw">+</span> (current-indentation) tab-width))
        (<span class="kw">setq</span> not-indented <span class="kw">nil</span>))

       <span class="co">;; found empty line, so just skip it</span>
       ((looking-at <span class="st">&quot;[ </span>\t<span class="st">]*$&quot;</span>))

       <span class="co">;; default case, so return indentation level of current line</span>
       (<span class="kw">t</span>
        (<span class="kw">setq</span> cur-indent (current-indentation))
        (<span class="kw">setq</span> not-indented <span class="kw">nil</span>))))
    cur-indent))</code></pre></div>
<p>Nothing special here. This function returns indentation level based on current block. This function makes assumption that previous non-empty line is well-indented. So we move one line up (<code>(forward-line -1)</code>) and when we face block-opening term, return it’s indentation level, increased by <code>tab-width</code>. When we face empty line, skip it. In other cases - just return indentation level of current line (not starting, but current).</p>
<p>Now let’s check <code>case</code> indentation rules.</p>
<div class="sourceCode"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(<span class="kw">defun</span><span class="fu"> fish-get-case-indent </span>()
  (interactive)
  (<span class="kw">let</span> ((not-indented <span class="kw">t</span>) cur-indent)
    (while not-indented
      <span class="co">;; move up</span>
      (forward-line -<span class="dv">1</span>)
      (<span class="kw">cond</span>
       <span class="co">;; found 'switch', so increase indentation level by tab-width</span>
       ((looking-at <span class="st">&quot;[ </span>\t<span class="st">]*</span>\\<span class="st">(switch</span>\\<span class="st">)&quot;</span>)
        (<span class="kw">setq</span> cur-indent (<span class="kw">+</span> (current-indentation) tab-width))
        (<span class="kw">setq</span> not-indented <span class="kw">nil</span>))

       <span class="co">;; found another 'case', so return it's indentation level</span>
       ((looking-at <span class="st">&quot;[ </span>\t<span class="st">]*</span>\\<span class="st">(case</span>\\<span class="st">)&quot;</span>)
        (<span class="kw">setq</span> cur-indent (current-indentation))
        (<span class="kw">setq</span> not-indented <span class="kw">nil</span>))

       <span class="co">;; found empty line, so just skip it</span>
       ((looking-at <span class="st">&quot;[ </span>\t<span class="st">]*$&quot;</span>))

       <span class="co">;; default case, so return indentation level of current line minus tab-width</span>
       (<span class="kw">t</span>
        (<span class="kw">setq</span> cur-indent (<span class="kw">-</span> (current-indentation) tab-width))
        (<span class="kw">setq</span> not-indented <span class="kw">nil</span>))))
    cur-indent))</code></pre></div>
<p>This function has similar pattern as previous one. It also uses previous non-empty line to decide what indentation level to use for current <code>case</code> term and this function also makes an assumption that previous non-empty line is well-indented. As you can see, for <code>case</code> term <code>switch</code> term behaves like block-opening. Next rule says that every <code>case</code> should be in one block. The last rule says that when we face something that not <code>switch</code> and not another <code>case</code>, we should return it’s indentation level and subtract <code>tab-width</code> from it.</p>
<p>The last and most important for me - <code>end</code> indentation function.</p>
<div class="sourceCode"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(<span class="kw">defun</span><span class="fu"> fish-get-end-indent </span>()
  (interactive)
  (<span class="kw">let</span> (cur-indent (count-of-ends <span class="dv">1</span>))
    (while (<span class="kw">not</span> (<span class="kw">eq</span> count-of-ends <span class="dv">0</span>))
      <span class="co">;; move up</span>
      (forward-line -<span class="dv">1</span>)
      (<span class="kw">cond</span>
       <span class="co">;; found block-opening term, so check if it matches to our end</span>
       ((looking-at <span class="st">&quot;[ </span>\t<span class="st">]*</span>\\<span class="st">(if</span>\\<span class="st">|function</span>\\<span class="st">|while</span>\\<span class="st">|for</span>\\<span class="st">|begin</span>\\<span class="st">|switch</span>\\<span class="st">)&quot;</span>)
        (<span class="kw">setq</span> count-of-ends (<span class="kw">-</span> count-of-ends <span class="dv">1</span>))
        (<span class="kw">if</span> (<span class="kw">eq</span> count-of-ends <span class="dv">0</span>)
            <span class="co">;; block-opening term matches, so return it's indentation level</span>
            (<span class="kw">progn</span> (<span class="kw">setq</span> cur-indent (current-indentation))
                   (<span class="kw">setq</span> pair-not-found <span class="kw">nil</span>))
          <span class="co">;; block-opening term does not match, so seek further</span>
          ))

       <span class="co">;; found another 'end', so increase count of 'end' terms</span>
       ((looking-at <span class="st">&quot;[ </span>\t<span class="st">]*</span>\\<span class="st">(end</span>\\<span class="st">)&quot;</span>)
        (<span class="kw">setq</span> count-of-ends (<span class="kw">+</span> count-of-ends <span class="dv">1</span>)))

       <span class="co">;; nothing interesting found, so seek further</span>
       (<span class="kw">t</span>)))
    cur-indent))</code></pre></div>
<p>This function searches for matching block opening term and returns it’s indentation level. For this purpose we use <code>count-of-ends</code> variable that stores how much <code>end~s are looking for their match. And when this function finds any block opening term, it reduces value of ~count-of-ends</code> by 1. And when this value is <code>0</code> - we found matching pair for <code>end</code> that we want to indent. Also be aware that we don’t count <code>else</code> as block opening term, because then we also need to count it as block closing term. Actually you can’t be sure if it will improve performance, so that’s why I leave <code>else</code> ignored.</p>
<p>So <code>fish-get-end-indent</code> function is a bit complicated. Here is a good example that makes it clear.</p>
<pre class="fish"><code>if test $ARG # open if block
  do_something1
  begin # open begin block
    do_something2
  end # close begin block
end # close if block
</code></pre>
<p>From this example it looks like we could implement <code>end</code> as <code>else</code> - just get current block indentation level and subtract from it <code>tab-width</code>. But here is example that counters this idea.</p>
<pre class="fish"><code>begin # open begin block
  switch $animal
    case cat
      echo evil
    case wolf dog human moose dolphin whale
      echo mammal
    case duck goose albatross
      echo bird
    case shark trout stingray
      echo fish
    case '*'
      echo I have no idea what a $animal is
  end # it closes switch block, but we need to subtract tab-width twice
end # closes begin block
</code></pre>
<p>So as you can see, this <code>switch-case</code> makes a lot of trouble. That’s why we need to seek for matching pair when we want to indent <code>end</code> term.</p>
<h1 id="sec-2">Shut up and give me my mode</h1>
<p>Feel free to hack my implementation on <a href="https://github.com/d12frosted/fish-mode">github</a>.</p>

<div id="info">
  <p>
    Posted on February  9, 2015
    
      by Boris Buliga
    
  </p>
  <p>
    Source: <a href="https://github.com/d12frosted/d12frosted.github.io/blob/source/posts/Fish-mode.org">Fish mode for emacs (v2)</a>
  </p>
</div>

    </div>
  </body>
</html>
